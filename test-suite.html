<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mimir Test Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        h1 { color: #333; text-align: center; }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-controls {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 12px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-secondary { background-color: #6c757d; color: white; }
        button:hover { opacity: 0.9; }
        .success { color: #28a745; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        .info { color: #17a2b8; }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #ddd;
        }
        .test-result.success { border-left-color: #28a745; background-color: #d4edda; }
        .test-result.error { border-left-color: #dc3545; background-color: #f8d7da; }
        .test-result.info { border-left-color: #17a2b8; background-color: #d1ecf1; }
        .summary {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .summary.success { background-color: #d4edda; color: #155724; }
        .summary.error { background-color: #f8d7da; color: #721c24; }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-number { font-size: 24px; font-weight: bold; color: #007bff; }
        .stat-label { color: #6c757d; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧠 Mimir Test Suite</h1>

        <div class="test-controls">
            <button class="btn-primary" onclick="runAllTests()">🚀 Run All Tests</button>
            <button class="btn-success" onclick="runCardCreationTests()">➕ Card Creation</button>
            <button class="btn-success" onclick="runCardReviewTests()">🧠 Card Review</button>
            <button class="btn-success" onclick="runCardEditingTests()">✏️ Card Editing</button>
            <button class="btn-success" onclick="runCardDeletionTests()">🗑️ Card Deletion</button>
            <button class="btn-secondary" onclick="runDatabaseTests()">🗄️ Database</button>
            <button class="btn-danger" onclick="clearTestData()">🧹 Clear Test Data</button>
        </div>

        <div id="test-summary"></div>

        <div class="test-section">
            <h2>📊 Test Statistics</h2>
            <div class="stats" id="test-stats">
                <div class="stat-card">
                    <div class="stat-number" id="total-tests">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="passed-tests">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="failed-tests">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="test-time">0ms</div>
                    <div class="stat-label">Execution Time</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>🗄️ Database Connection Tests</h2>
            <div id="database-results"></div>
        </div>

        <div class="test-section">
            <h2>➕ Card Creation Tests</h2>
            <div id="creation-results"></div>
        </div>

        <div class="test-section">
            <h2>🧠 Card Review Tests</h2>
            <div id="review-results"></div>
        </div>

        <div class="test-section">
            <h2>✏️ Card Editing Tests</h2>
            <div id="editing-results"></div>
        </div>

        <div class="test-section">
            <h2>🗑️ Card Deletion Tests</h2>
            <div id="deletion-results"></div>
        </div>
    </div>

    <!-- Include dependencies -->
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>
    <script src="js/database-dexie.js"></script>
    <script src="js/scheduler.js"></script>

    <script>
        // Test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
                this.startTime = 0;
            }

            async runTest(name, testFn) {
                try {
                    await testFn();
                    this.results.push({ name, status: 'passed', error: null });
                    return true;
                } catch (error) {
                    this.results.push({ name, status: 'failed', error: error.message });
                    return false;
                }
            }

            displayResult(containerId, name, status, error = null) {
                const container = document.getElementById(containerId);
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result ${status}`;

                if (status === 'passed') {
                    resultDiv.innerHTML = `<span class="success">✓ ${name}</span>`;
                } else {
                    resultDiv.innerHTML = `<span class="error">✗ ${name}</span><br><small>${error}</small>`;
                }

                container.appendChild(resultDiv);
            }

            updateStats() {
                const total = this.results.length;
                const passed = this.results.filter(r => r.status === 'passed').length;
                const failed = total - passed;
                const time = Date.now() - this.startTime;

                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
                document.getElementById('test-time').textContent = `${time}ms`;

                const summaryDiv = document.getElementById('test-summary');
                if (failed === 0 && total > 0) {
                    summaryDiv.innerHTML = `<div class="summary success">🎉 All ${total} tests passed!</div>`;
                } else if (total > 0) {
                    summaryDiv.innerHTML = `<div class="summary error">❌ ${failed} of ${total} tests failed</div>`;
                }
            }

            clearResults() {
                this.results = [];
                ['database-results', 'creation-results', 'review-results', 'editing-results', 'deletion-results'].forEach(id => {
                    document.getElementById(id).innerHTML = '';
                });
                document.getElementById('test-summary').innerHTML = '';
            }
        }

        const testRunner = new TestRunner();

        // Test data generators
        function generateTestCard(suffix = '') {
            const timestamp = Date.now() + Math.random();
            return {
                card_id: `test-card-${timestamp}${suffix}`,
                prompt: `Test prompt ${suffix} ${timestamp}`,
                response: `Test response ${suffix} ${timestamp}`,
                tags: ['test', `tag-${suffix}`],
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            };
        }

        // Database Tests
        async function runDatabaseTests() {
            testRunner.clearResults();
            testRunner.startTime = Date.now();

            // Test 1: Database Connection
            await testRunner.runTest('Database Connection', async () => {
                await MimirDB.init();
            });
            testRunner.displayResult('database-results', 'Database Connection', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 2: Database Stats
            await testRunner.runTest('Database Stats', async () => {
                const stats = await MimirDB.getStats();
                if (typeof stats.totalCards !== 'number') throw new Error('Invalid stats format');
            });
            testRunner.displayResult('database-results', 'Database Stats', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            testRunner.updateStats();
        }

        // Card Creation Tests
        async function runCardCreationTests() {
            const containerId = 'creation-results';
            document.getElementById(containerId).innerHTML = '';

            // Test 1: Basic Card Creation
            await testRunner.runTest('Basic Card Creation', async () => {
                const testCard = generateTestCard('basic');
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                await MimirDB.saveCard(initializedCard);

                // Verify card was saved
                const allCards = await MimirDB.getAllCards();
                const savedCard = allCards.find(c => c.card_id === initializedCard.card_id);
                if (!savedCard) throw new Error('Card not found after save');

                // Cleanup
                await MimirDB.deleteCard(initializedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Basic Card Creation', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 2: Card with Tags
            await testRunner.runTest('Card Creation with Tags', async () => {
                const testCard = generateTestCard('tags');
                testCard.tags = ['math', 'algebra', 'equations'];
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                await MimirDB.saveCard(initializedCard);

                // Verify tags were saved
                const savedCards = await MimirDB.getCardsByTags(['math']);
                const savedCard = savedCards.find(c => c.card_id === initializedCard.card_id);
                if (!savedCard || !savedCard.tags.includes('math')) throw new Error('Tags not saved correctly');

                // Cleanup
                await MimirDB.deleteCard(initializedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Card Creation with Tags', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 3: Scheduling Initialization
            await testRunner.runTest('Scheduling Fields Initialization', async () => {
                const testCard = generateTestCard('scheduling');
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);

                if (!initializedCard.due_date) throw new Error('due_date not initialized');
                if (initializedCard.review_interval !== 0) throw new Error('review_interval not initialized to 0');
                if (initializedCard.review_count !== 0) throw new Error('review_count not initialized to 0');

                await MimirDB.saveCard(initializedCard);

                // Cleanup
                await MimirDB.deleteCard(initializedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Scheduling Fields Initialization', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            testRunner.updateStats();
        }

        // Card Review Tests
        async function runCardReviewTests() {
            const containerId = 'review-results';
            document.getElementById(containerId).innerHTML = '';

            // Test 1: Successful Review Scheduling
            await testRunner.runTest('Successful Review Scheduling', async () => {
                const testCard = generateTestCard('review-success');
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                await MimirDB.saveCard(initializedCard);

                // Simulate successful review
                const reviewedCard = SpacedRepetitionScheduler.scheduleCard(initializedCard, true);
                await MimirDB.updateCard(reviewedCard);

                // Verify scheduling updates
                if (reviewedCard.review_interval !== 1) throw new Error('Review interval not incremented');
                if (reviewedCard.review_count !== 1) throw new Error('Review count not incremented');
                if (!reviewedCard.last_reviewed) throw new Error('Last reviewed not set');

                // Verify due date is in the future (2^1 = 2 days)
                const dueDate = new Date(reviewedCard.due_date);
                const today = new Date();
                if (dueDate <= today) throw new Error('Due date not scheduled correctly');

                // Cleanup
                await MimirDB.deleteCard(reviewedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Successful Review Scheduling', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 2: Failed Review Scheduling
            await testRunner.runTest('Failed Review Scheduling', async () => {
                const testCard = generateTestCard('review-failed');
                let initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                initializedCard.review_interval = 3; // Set to higher interval
                await MimirDB.saveCard(initializedCard);

                // Simulate failed review
                const reviewedCard = SpacedRepetitionScheduler.scheduleCard(initializedCard, false);
                await MimirDB.updateCard(reviewedCard);

                // Verify interval reset to 0
                if (reviewedCard.review_interval !== 0) throw new Error('Review interval not reset to 0');
                if (reviewedCard.review_count === 0) throw new Error('Review count should still increment');

                // Cleanup
                await MimirDB.deleteCard(reviewedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Failed Review Scheduling', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 3: Due Cards Query
            await testRunner.runTest('Due Cards Query', async () => {
                // Create a card that's due today
                const testCard = generateTestCard('due-today');
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                initializedCard.due_date = new Date().toISOString(); // Due today
                await MimirDB.saveCard(initializedCard);

                // Query due cards
                const dueCards = await MimirDB.getDueCards();
                const foundCard = dueCards.find(c => c.card_id === initializedCard.card_id);
                if (!foundCard) throw new Error('Due card not found in query');

                // Cleanup
                await MimirDB.deleteCard(initializedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Due Cards Query', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            testRunner.updateStats();
        }

        // Card Editing Tests
        async function runCardEditingTests() {
            const containerId = 'editing-results';
            document.getElementById(containerId).innerHTML = '';

            // Test 1: Basic Card Editing
            await testRunner.runTest('Basic Card Editing', async () => {
                const testCard = generateTestCard('edit-basic');
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                await MimirDB.saveCard(initializedCard);

                // Edit the card
                const editedCard = { ...initializedCard };
                editedCard.prompt = 'Updated prompt';
                editedCard.response = 'Updated response';
                editedCard.updated_at = new Date().toISOString();

                await MimirDB.updateCard(editedCard);

                // Verify changes
                const allCards = await MimirDB.getAllCards();
                const updatedCard = allCards.find(c => c.card_id === editedCard.card_id);
                if (!updatedCard) throw new Error('Card not found after update');
                if (updatedCard.prompt !== 'Updated prompt') throw new Error('Prompt not updated');
                if (updatedCard.response !== 'Updated response') throw new Error('Response not updated');

                // Cleanup
                await MimirDB.deleteCard(editedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Basic Card Editing', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 2: Tag Editing
            await testRunner.runTest('Tag Editing', async () => {
                const testCard = generateTestCard('edit-tags');
                testCard.tags = ['original', 'tags'];
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                await MimirDB.saveCard(initializedCard);

                // Edit tags
                const editedCard = { ...initializedCard };
                editedCard.tags = ['new', 'updated', 'tags'];
                editedCard.updated_at = new Date().toISOString();

                await MimirDB.updateCard(editedCard);

                // Verify tag changes
                const taggedCards = await MimirDB.getCardsByTags(['new']);
                const foundCard = taggedCards.find(c => c.card_id === editedCard.card_id);
                if (!foundCard) throw new Error('Card not found with new tags');

                // Cleanup
                await MimirDB.deleteCard(editedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Tag Editing', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 3: Preserve Scheduling Data
            await testRunner.runTest('Preserve Scheduling Data During Edit', async () => {
                const testCard = generateTestCard('edit-preserve');
                let initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);

                // Simulate some review history
                initializedCard.review_interval = 2;
                initializedCard.review_count = 3;
                initializedCard.last_reviewed = new Date().toISOString();

                await MimirDB.saveCard(initializedCard);

                // Edit content but preserve scheduling
                const editedCard = { ...initializedCard };
                editedCard.prompt = 'Edited prompt';
                editedCard.updated_at = new Date().toISOString();

                await MimirDB.updateCard(editedCard);

                // Verify scheduling data preserved
                const allCards = await MimirDB.getAllCards();
                const updatedCard = allCards.find(c => c.card_id === editedCard.card_id);
                if (updatedCard.review_interval !== 2) throw new Error('Review interval not preserved');
                if (updatedCard.review_count !== 3) throw new Error('Review count not preserved');
                if (!updatedCard.last_reviewed) throw new Error('Last reviewed not preserved');

                // Cleanup
                await MimirDB.deleteCard(editedCard.card_id);
            });
            testRunner.displayResult(containerId, 'Preserve Scheduling Data During Edit', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            testRunner.updateStats();
        }

        // Card Deletion Tests
        async function runCardDeletionTests() {
            const containerId = 'deletion-results';
            document.getElementById(containerId).innerHTML = '';

            // Test 1: Basic Card Deletion
            await testRunner.runTest('Basic Card Deletion', async () => {
                const testCard = generateTestCard('delete-basic');
                const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                await MimirDB.saveCard(initializedCard);

                // Verify card exists
                let allCards = await MimirDB.getAllCards();
                let foundCard = allCards.find(c => c.card_id === initializedCard.card_id);
                if (!foundCard) throw new Error('Card not found before deletion');

                // Delete the card
                await MimirDB.deleteCard(initializedCard.card_id);

                // Verify card is deleted
                allCards = await MimirDB.getAllCards();
                foundCard = allCards.find(c => c.card_id === initializedCard.card_id);
                if (foundCard) throw new Error('Card still exists after deletion');
            });
            testRunner.displayResult(containerId, 'Basic Card Deletion', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 2: Delete Non-existent Card
            await testRunner.runTest('Delete Non-existent Card', async () => {
                const fakeId = 'non-existent-card-' + Date.now();

                // This should not throw an error
                await MimirDB.deleteCard(fakeId);

                // Verify no issues occurred
                const stats = await MimirDB.getStats();
                if (typeof stats.totalCards !== 'number') throw new Error('Database corrupted after deleting non-existent card');
            });
            testRunner.displayResult(containerId, 'Delete Non-existent Card', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            // Test 3: Bulk Deletion Test
            await testRunner.runTest('Bulk Deletion Test', async () => {
                // Create multiple test cards
                const testCards = [];
                for (let i = 0; i < 5; i++) {
                    const testCard = generateTestCard(`bulk-${i}`);
                    const initializedCard = SpacedRepetitionScheduler.initializeCard(testCard);
                    await MimirDB.saveCard(initializedCard);
                    testCards.push(initializedCard);
                }

                // Delete all test cards
                for (const card of testCards) {
                    await MimirDB.deleteCard(card.card_id);
                }

                // Verify all cards are deleted
                const allCards = await MimirDB.getAllCards();
                for (const card of testCards) {
                    const foundCard = allCards.find(c => c.card_id === card.card_id);
                    if (foundCard) throw new Error(`Card ${card.card_id} still exists after bulk deletion`);
                }
            });
            testRunner.displayResult(containerId, 'Bulk Deletion Test', testRunner.results[testRunner.results.length - 1].status, testRunner.results[testRunner.results.length - 1].error);

            testRunner.updateStats();
        }

        // Main test runner
        async function runAllTests() {
            testRunner.clearResults();
            testRunner.startTime = Date.now();

            console.log('🚀 Starting comprehensive test suite...');

            // Run all test suites
            await runDatabaseTests();
            await runCardCreationTests();
            await runCardReviewTests();
            await runCardEditingTests();
            await runCardDeletionTests();

            console.log('✅ Test suite completed');

            // Final summary
            const total = testRunner.results.length;
            const passed = testRunner.results.filter(r => r.status === 'passed').length;
            const failed = total - passed;

            if (failed === 0) {
                console.log(`🎉 All ${total} tests passed!`);
            } else {
                console.log(`❌ ${failed} of ${total} tests failed`);
                console.log('Failed tests:', testRunner.results.filter(r => r.status === 'failed'));
            }
        }

        // Utility function to clear test data
        async function clearTestData() {
            if (confirm('Are you sure you want to clear all test data? This will remove any cards with "test" in their ID.')) {
                try {
                    const allCards = await MimirDB.getAllCards();
                    const testCards = allCards.filter(card => card.card_id.includes('test'));

                    for (const card of testCards) {
                        await MimirDB.deleteCard(card.card_id);
                    }

                    alert(`Cleared ${testCards.length} test cards`);
                    console.log(`Cleared ${testCards.length} test cards`);
                } catch (error) {
                    alert('Error clearing test data: ' + error.message);
                    console.error('Error clearing test data:', error);
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await MimirDB.init();
                console.log('Test suite initialized - database ready');

                // Show initial stats
                const stats = await MimirDB.getStats();
                console.log('Current database stats:', stats);

                // Add info message
                const summaryDiv = document.getElementById('test-summary');
                summaryDiv.innerHTML = `<div class="summary info">📊 Database ready - ${stats.totalCards} cards, ${stats.totalTags} unique tags</div>`;

            } catch (error) {
                console.error('Failed to initialize test suite:', error);
                const summaryDiv = document.getElementById('test-summary');
                summaryDiv.innerHTML = `<div class="summary error">❌ Failed to initialize database: ${error.message}</div>`;
            }
        });
    </script>
</body>
</html>